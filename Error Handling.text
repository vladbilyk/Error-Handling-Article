Варианты обработки ошибок
=========================

При разработке любого сервисного кода (т.е. кода, который будет вызываться
каким-либо другим кодом) рано или поздно возникает необходимость сообщать о
статусе выполнения операции: успешно ли она завершилась или неуспешно. Если в
случае успешного завершения, последовательность исполнения действий вызывающей
стороны не будет отклоняться от задуманной, то в случае неуспешного завершения
операции на вызывающей стороне часто требуются различные действия в зависимости
от причины провала вызванной операции (например, нотификация пользователя,
изменения состояния программы и т.д.).

Существую два распространенных механизма уведомления/и обработки ошибок:

-   Механизм исключений (exceptions)

-   Использование кодов возврата

TODO: ссылки

TODO: Дать общие описания подходов.

TODO: Определить их отличия, и понять когда и что лучше применять.

TODO: (следующий раздел) Далее более детальное сравнение реализаций в разных
языках программирования.

Подходы к обработке ошибок
==========================

Идиомы обработки, принятые в разных языках и фреймворках.

-   Win32/C++ (WTL, MFC)

-   не-UI C/C++ и всякие platform-abstraction layers типа APR, libuv.

-   Objective-C / Cocoa

    Методы, в которых возможны операционные ошибки, как правило, возвращают
    признак «успешно/неуспешно» и имеют последний параметр `(NSError**)error`, в
    который вызывающая сторона должна записать адрес указателя на объект
    `NSError`. Если ошибка возникла то в `error` будут подробности, в том числе
    код ошибки и локализованное описание. Простейший код отображения ошибки
    пользователю выглядит так.

    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    NSError *error;
    if (![doc readFromData:data ofType:type error:&error]) {
      [NSApp presentError:error];
      return;
    }
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

-   C# / .NET Framework

    В C# широко используются 2 подхода: бросание/обработка исключений и паттерн
    Trier-Doer.

    Про обработку исключений можно писать долго, из специфических вещей в C#
    есть оператор using, гарантирующий вызов метода Dispose при выходе за
    границу оператора (обеспечивая таким образом освобождение
    ресурсов)[^cs-using-st].

    [^cs-using-st] using Statement (C# Reference)
    <http://msdn.microsoft.com/en-us/library/yh598w02.aspx>

    Идея паттерна Trier-Doer состоит в том, чтобы к методу выполняющему
    некоторое действие (Do), и бросающему исключение в случае неудачи,
    обеспечить парный метод (Try), сообщающий будет ли действие (Do) успешным.
    Примером является связка методов Int32.Parse и Int32.TryParse, преобразующих
    строку в целое число:

    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    public static int Parse( string s );
    public static bool TryParse( string s, out int result );
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

-   Java

-   JavaScript

    В асинхронном коде принято передавать первым параметром в колбэк объект
    ошибки (или `null` если нет ошибки). Например, так.

    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    function async_divide(a, b, callback) {
      if (b === 0)
        callback(new Error('Cannot divide by zero'));
      callback(null, a / b);
    }
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

-   Erlang

-   Haskel?

-   Go?

-   Python, Ruby, Perl, PHP?

// Ф: Взять для примера какую-нибудь задачу и реализовать её с красивой
обработкой ошибок на нескольких языках?

Сравнение и анализ
==================

Что лучше, удобнее.

Существует ли универсальная реализация?

Попробовать ее реализовать.

Мысли
=====

-   Интересная идея: возвращать объект с кодом ошибки, который бросает
    исключение если вызывающий код не спросил код ошибки—так сказать “Exploding
    Errors”. Отсюда из одного из
    комментариев<http://damienkatz.net/2006/04/error_code_vs_e.html>
