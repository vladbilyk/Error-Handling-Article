Варианты обработки ошибок
=========================

При разработке любого сервисного кода (т.е. кода, который будет вызываться
каким-либо другим кодом) рано или поздно возникает необходимость сообщать о
статусе выполнения операции: успешно ли она завершилась или неуспешно. Если в
случае успешного завершения, последовательность исполнения действий вызывающей
стороны не будет отклоняться от задуманной, то в случае неуспешного завершения
операции на вызывающей стороне часто требуются различные действия в зависимости
от причины провала вызванной операции (например, нотификация пользователя,
изменения состояния программы и т.д.).

Существую два распространенных механизма уведомления/и обработки ошибок:

-   Механизм исключений (exceptions)

-   Использование кодов возврата

TODO: ссылки

TODO: Дать общие описания подходов.

TODO: Определить их отличия, и понять когда и что лучше применять.

TODO: (следующий раздел) Далее более детальное сравнение реализаций в разных
языках программирования.

Подходы к обработке ошибок
==========================

Идиомы обработки, принятые в разных языках и фреймворках.

-   Win32/C++ (WTL, MFC)

-   не-UI C/C++ и всякие platform-abstraction layers типа APR, libuv.

-   Objective-C / Cocoa

    Методы, в которых возможны операционные ошибки, как правило, возвращают
    признак «успешно/неуспешно» и имеют последний параметр `(NSError**)error`, в
    который вызывающая сторона должна записать адрес указателя на объект
    `NSError`. Если ошибка возникла то в `error` будут подробности, в том числе
    код ошибки и локализованное описание. Простейший код отображения ошибки
    пользователю выглядит так.

    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    NSError *error;
    if (![doc readFromData:data ofType:type error:&error]) {
      [NSApp presentError:error];
      return;
    }
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

    Описание обработки ошибок в Objective-C: 
    <https://developer.apple.com/library/mac/#documentation/Cocoa/Conceptual/ErrorHandlingCocoa/ErrorHandling/ErrorHandling.html>

-   C# / .NET Framework

    В .NET Framework и Common Language Runtime основным подходом к обработке
    ошибок является механизм исключений, который поддерживает работу как с
    управляемыми (managed), так и с неуправляемыми (unmanaged) исключениями
    универсальным образом. CLR определяет универсальную модель исключений,
    которая немного варьируется между спецификацими CLR-совместимых языков
    [^clr-exceptions].

    [^clr-exceptions] Handling and Throwing Exceptions
    <http://msdn.microsoft.com/en-US/library/5b2yeyab(v=vs.110).aspx>

    Про обработку исключений можно писать долго, она очень похожа на C++ и Java.
    Из специфических вещей в C# есть оператор using, гарантирующий вызов метода
    `Dispose` при выходе за границу оператора (обеспечивая таким образом
    освобождение ресурсов)[^cs-using-st].

    [^cs-using-st] using Statement (C# Reference)
    <http://msdn.microsoft.com/en-us/library/yh598w02.aspx>

    Повсеместное использование исключений может приводить к снижению
    производительности, поэтому Microsoft рекомендует использовать 2 похожих
    паттерна в критических для производительности случаях
    [^exc-performance-guidelines-msdn]: Tester-Doer и TryX метод.

    [^exc-performance-guidelines-msdn] Exceptions and Performance. Design
    Guidelines for Developing Class Libraries.
    <http://msdn.microsoft.com/en-US/library/ms229009(v=vs.100).aspx>

    Идея паттерна Tester-Doer состоит в том, чтобы к методу выполняющему
    некоторое действие (Do), и бросающему исключение в случае неудачи,
    обеспечить проверку (потокобезопасную) сообщающую будет ли действие (Do)
    успешным. Так, например, индексер класса `Dictionary<TKey, TValue>` бросает
    исключение `KeyNotFoundException`, если соответсвующий ключ в коллекции не
    найден, а метод `ContainsKey` осуществляет проверку наличия ключа.

    Метод `Dictionary<TKey, TValue>.TryGetValue` со следующим прототипом:

    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    bool TryGetValue(TKey key, out TValue value);
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

    Если коллекция содержит ключ `key`, то метод `TryGetValue` возвращает `true`
    и записывает в параметер `value `соответствующее значение, а в противном
    случае возвращает `false`. Данный метод является примером шаблона TryX
    метод.

-   Java

-   JavaScript

    В асинхронном коде принято передавать первым параметром в колбэк объект
    ошибки (или `null` если нет ошибки). Например, так.

    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    function async_divide(a, b, callback) {
      if (b === 0)
        callback(new Error('Cannot divide by zero'));
      callback(null, a / b);
    }
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

-   Erlang

-   Eiffel

    В Eiffel используются своеобразный подход к исключениям, называемый
    дисциплинированными исключениями (disciplined exceptions)
    [^disc-exceptions].

    [^disc-exceptions] Bertrand Meyer. Disciplined Exceptions. Interactive
    Software Engineering, 1988.

    Этот подход подразумевает, что исключения должны использоваться только в
    ненормальных ситуациях, которые могут приводить непредсказуемому поведению
    системы. Бросание и обработка исключений реализуется в соответствии с
    принципом разработки по контракту (Design by Contract), являющимся
    основополагающим в Eiffel. Исключения бросаются при невыполнении контракта
    (предусловия и постусловия), или из тела функции. Обрабатываются исключения
    в специальном блоке `rescue` из которого вызывается повторное выполнение
    функции (или происходит очистка ресурсов и проброс исключения на уровень
    выше). Пример:

    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    get_integer_from_user: INTEGER is  
      -- Read an integer (allow user up to five attempts)  
    local  
      failed: INTEGER
    do 
      Result := getint
    rescue 
      failed := failed+1; 
      if failed <= 5 then 
        message ("Input must be an integer. Please enter again:");
        retry 
      end; 
    end -- get_integer_from_user
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

-   Haskel?

-   Go?

-   Python, Ruby, Perl, PHP?

Сравнение и анализ
==================

Что лучше, удобнее.

Существует ли универсальная реализация?

Попробовать ее реализовать.
